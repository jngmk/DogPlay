---
title: 'Android 프로세스 및 애플리케이션 수명 주기'
date: '2020-05-12 17:27'
slug: '/dev/app/2020-05-12-process-life-cycle'
category1: 'dev'
category2: 'app'
tags: ['app', 'android', 'process life cycle']
---



###### 안드로이드 앱을 처음 개발해보게 되었다. 공식문서를 보며 프로세스 및 애플리케이션 수명 주기를 공부했고, 그 내용을 요약했다.

<!-- end -->



애플리케이션 개발자는 다양한 애플리케이션 구성요소(특히 `Activity`, `Service` 및 `BroadcastReceiver`)가 애플리케이션 프로세스의 수명 주기 전체 기간에 영향을 미치는 방식을 이해하는 것이 중요하다. 이러한 구성요소를 올바르게 사용하지 않으면 시스템이 중요한 작업을 하는 동안 애플리케이션 프로세스가 종료될 수 있다.

프로세스 수명 주기 버그의 일반적인 예는 `BroadcastReceiver`로 이 클래스는 `BroadcastReceiver.onReceive()` 메서드의 인텐트를 수신한 후 함수에서 반환될 때 스레드를 시작한다. 반환된 후에는 시스템에서 `BroadcastReceiver` 가 더 이상 활성 상태가 아닌 것으로 간주하므로 호스팅 프로세스가 더 이상 필요하지 않다(다른 애플리케이션 구성요소가 이 프로세스 내에서 활성 상태가 아닌 한). 따라서 시스템에서 언제든지 프로세스를 종료하여 메모리를 회수할 수 있다. 이 과정에서 시스템은 생성되어 프로세스에서 실행 중인 스레드를 종료한다. 이 문제를 해결하는 방법은 일반적으로 `BroadcastReceiver` 의 `JobService`를 예약하는 것이다. 그러면 시스템에서 프로세스에 아직 진행 중인 활성 작업이 있다는 것을 알수 있다.



## 프로세스 중요도

### 1. 포그라운드 프로세스

사용자가 현재 하고 있는 작업에 필요한 프로세스이다. 다양한 애플리케이션 구성요소로 인해 포함된 프로세스가 다양한 방식으로 포그라운드로 간주될 수 있다. 다음 조건 중 하나라도 해당하면 프로세스가 포그라운드에 있는 것으로 간주된다.

- 프로세스가 사용자가 상호작용하고 있는 화면 상단에서 `Activity`를 실행 중이다(`onResume()` 메서드가 호출되었음).
- 프로세스에 현재 실행 중인 `BroadcastReceiver`가 있습니다(`BroadcastReceiver.onReceive()` 메서드가 실행 중).
- 프로세스에 콜백(`Service.onCreate()`, `Service.onStart()` 또는 `Service.onDestroy()`) 중 하나에서 현재 코드를 실행 중인 `Service`가 있다.

1. 이러한 프로세스는 시스템에 몇 개밖에 없다. 메모리가 매우 부족하여 이러한 프로세스조차 계속 실행할 수 없을 때 최후의 수단으로만 포그라운드 프로세스를 종료한다.



### 2. 가시적 프로세스

사용자가 현재 알고 있는 작업이므로 이 프로세스를 종료하면 사용자 환경에 분명히 부정적인 영향을 미친다. 다음 조건에 해당하는 프로세스가 가시적 프로세스로 간주된다.

- 프로세스가 화면상으로는 사용자에게 표시되지만 포그라운드에 있지 않은 `Activity`를 실행 중이다(`onPause()` 메서드가 호출되었음).
- 프로세스에 `Service.startForeground()`를 통해 포그라운드 서비스로 실행 중인 `Service`가 있다(`Service.startForeground()`는 서비스를 사용자가 알고 있는 것 또는 기본적으로 사용자에게 표시되는 것으로 처리하도록 시스템에 요청함).
- 프로세스가 시스템에서 라이브 배경화면, 입력 방법 서비스 등과 같이 사용자가 알고 있는 특정 기능에 사용하는 서비스를 호스팅하고 있다.

시스템에서 실행 중인 이러한 프로세스의 수는 포그라운드 프로세스보다 덜 제한적이지만 그럼에도 비교적 관리되는 편이다. 이러한 프로세스는 매우 중요한 것으로 간주되며 프로세스의 종료가 모든 포그라운드 프로세스의 실행 상태를 유지하는 데 필요한 상황이 아니라면 종료되지 않는다.



### 3. 서비스 프로세스

`startService()` 메서드로 시작된 `Service`를 유지하는 프로세스이다. 이러한 프로세스는 사용자에게 직접 표시되지 않지만 일반적으로 사용자가 관심을 가진 작업(예: 백그라운드 네트워크 데이터 업로드 또는 다운로드)을 실행한다. 따라서 시스템은 모든 포그라운드 프로세스 및 가시적 프로세스를 유지할 메모리가 부족하지 않다면 항상 이러한 프로세스의 실행 상태를 유지한다.

오랫동안(예: 30분 이상) 실행되고 있는 서비스는 중요도가 강등됨에 따라 이 프로세스가 캐시된 LRU 목록으로 이전될 수 있다. 이렇게 하면 메모리 누출 또는 기타 문제가 있는 장기 실행 서비스가 너무 많은 RAM을 소비하여 시스템이 캐시된 프로세스를 효과적으로 활용하지 못하게 하는 상황을 방지할 수 있다.



### 4. 캐시된 프로세스

현재 필요하지 않은 프로세스이다. 시스템은 다른 곳에서 메모리가 필요할 때 언제든 원하는 대로 이 프로세스를 종료할 수 있다. 정상적으로 작동하는 시스템에서 캐시된 프로세스는 메모리 관리와 관련된 유일한 프로세스이다. 제대로 운영되는 시스템에서는 다수의 캐시된 프로세스가 항상 사용 가능하며(효율적인 애플리케이션 간 전환을 위해) 필요에 따라 가장 오래된 프로세스를 정기적으로 종료한다. 매우 심각한(그리고 바람직하지 않은) 상황에서만 시스템이 캐시된 프로세스를 모두 종료하고 서비스 프로세스 종료를 시작해야 하는 시점에 이르게 된다.

흔히 캐시된 프로세스는 현재 사용자에게 표시되지 않는 하나 이상의 `Activity` 인스턴스를 포함합니다(`onStop()` 메서드가 호출되어 반환되었음). 캐시된 프로세스가 활동 수명 주기를 올바르게 구현하면(자세한 내용은 `Activity` 참조) 시스템이 이러한 프로세스를 종료해도 앱으로 돌아갈 때 사용자 환경에 영향을 주지 않는다. 그리고 연결된 활동이 새 프로세스에서 다시 생성될 때 시스템이 이전에 저장된 상태를 복원할 수 있다.

